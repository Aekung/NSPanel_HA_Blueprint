#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - BOOT                                                                       #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
api:
  id: !extend api_server
  on_client_connected:
    then:
      - lambda: |-
          if (current_page->state == "boot") boot_log->execute("API", "Client connected");

display:
  - id: !extend disp1
    on_setup:
      - script.execute:
          id: boot_log
          category: Nextion
          log_message: on_setup
      - if:
          condition:
            - lambda: return (!id(is_uploading_tft));
          then:
            - script.execute: boot_sequence
            - script.wait: boot_sequence
            - lambda: |-
                ESP_LOGI("display.on_setup", "Boot sequence completed.");
            - delay: 2s
            - lambda: |-
                nextion_init->publish_state(true);

    on_touch:
      then:
        - lambda: |-
            if (page_id == 0) {  // Boot
              switch (component_id) {
                case 24:  // Reboot button
                  if (!touch_event) {  // Release
                    arch_restart();
                  }
                  break;
              }
            }

esphome:
  on_boot:
    - priority: 600.0  # This is where most sensors are set up.
      then:
        - lambda: |-
            boot_log->execute("on_boot", "Set time zone");
            set_timezone->execute(id(mui_timezone).c_str());
            boot_log->execute("on_boot", "Publish device name");
            device_name->publish_state("${name}");
            boot_log->execute("on_boot", "Reset notification entities");
            notification_label->publish_state("");
            notification_text->publish_state("");
            notification_unread->turn_off();
        - wait_until:
            condition:
              - lambda: return (not isnan(stoi(baud_rate->state)));
            timeout: 60s
        - lambda: |-
            boot_log->execute("on_boot", "Set baud rate");
            if (stoi(baud_rate->state) != tf_uart->get_baud_rate()) set_baud_rate->execute(stoi(baud_rate->state), true);
        - wait_until:
            condition:
              - lambda: return disp1->is_setup();
            timeout: 60s
        - if:
            condition:
              - lambda: return (not disp1->is_detected());
            then:
              - lambda: boot_log->execute("on_boot", "Restart Nextion");
              - switch.turn_off: screen_power
              - delay: 2s
              - switch.turn_on: screen_power

globals:
  - id: boot_progress_count
    type: uint8_t
    restore_value: false
    initial_value: '0'

script:
  - id: boot_event
    mode: restart
    parameters:
      init: bool
    then:
      - lambda: |-
          if (init) {
            esphome::api::CustomAPIDevice ha_event;
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
              {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "boot"},
                {"step", "start"}
              });
          }
      - while:
          condition:
            - lambda: return !is_boot_complete();
          then:
            - delay: 20s
            - lambda: |-
                if (!is_boot_complete()) {
                  esphome::api::CustomAPIDevice ha_event;
                  ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                    {
                      {"device_name", device_name->state.c_str()},
                      {"esphome_version", "${version}"},
                      {"type", "boot"},
                      {"step", "timeout"}
                    });
                }

  - id: boot_log
    mode: queued
    # max_runs: 15
    parameters:
      category: string
      log_message: string
    then:
      - lambda: |-
          ESP_LOGI("script.boot_log", "%s: %s", category.c_str(), log_message.c_str());
          if (current_page->state == "boot") {
            disp1->send_command_printf("log_body.txt+=\"%s: %s\\r\"", category.c_str(), log_message.c_str());
          }

  - id: boot_progress
    mode: restart
    parameters:
      step: uint32_t
    then:
      - script.execute: boot_progress_dump
      - lambda: |-
          complete_boot_step(step);
          timer_reset_all->execute();
          if (is_boot_complete())
            ESP_LOGI("script.boot_progress", "Progress: Completed");
          else
            ESP_LOGI("script.boot_progress", "Progress: %" PRIu8 "/%" PRIu32 " (%" PRIu8 "%%)", get_boot_steps_completed(), TOTAL_BOOT_STEPS, get_boot_progress_percentage());
          if (current_page->state == "boot") {
            disp1->set_component_value("progress", get_boot_progress_percentage());
            if (!isnan(display_charset->state) and !isnan(display_mode->state) and !version_tft->state.empty())
              disp1->send_command("tm_esphome.en=0");
          }

  - id: boot_progress_dump
    mode: restart
    then:
      - delay: 20s
      - lambda: |-
          ESP_LOGCONFIG("script.boot_progress_dump", "Boot progress: %d%%", get_boot_progress_percentage());
          ESP_LOGCONFIG("script.boot_progress_dump", " - Boot:                 %s", is_boot_step_completed(BOOT_STEP_BOOT) ? "Completed" : "PENDING");

  - id: boot_sequence
    mode: restart
    then:
      - lambda: |-
          ESP_LOGI("script.boot_sequence", "Starting boot sequence...");
          boot_progress->execute(BOOT_STEP_BOOT );
      # Extended by:
      # nspanel_esphome_core_page_home.yaml

  - id: !extend dump_config_report
    then:
      - lambda: |-
          // Report boot progress
          if (is_boot_complete()) {
            ESP_LOGCONFIG("${project_tag}", "  Boot steps:  %" PRIu8 "/%" PRIu32 " (100%%)", get_boot_steps_completed(), TOTAL_BOOT_STEPS);
          } else {
            ESP_LOGW("${project_tag}", "  Boot steps:  %" PRIu8 "/%" PRIu32 " (%" PRIu8 "%%)", get_boot_steps_completed(), TOTAL_BOOT_STEPS, get_boot_progress_percentage());
            ESP_LOGW("${project_tag}", "  State:       %s", ((wifi_component->is_connected()) and api_server->is_connected()) ? "Pending" : "DISCONNECTED");
            ESP_LOGCONFIG("${project_tag}", "Requesting new boot parameters from Blueprint");
            boot_event->execute(false);
          }

  - id: page_boot
    mode: single
    then:
      - logger.log: Page boot called
      - lambda: |-
          boot_log->execute("Boot", "Starting sequence");
          boot_progress->execute(0);
          set_brightness->execute(100);
          update_tft_info->execute();
          boot_log->execute("Boot", "ESPHome FW v${version}");
          disp1->set_component_text("ver_firmware", "Firmware: ${version}");  // ESPHome version
          boot_progress->execute(1);
          #ifdef ARDUINO
          boot_log->execute("Boot", "Framework is Arduino");
          disp1->set_component_text("sys_framework", "Framework: Arduino");
          #elif defined(USE_ESP_IDF)
          boot_log->execute("Boot", "Framework is ESP-IDF");
          disp1->set_component_text("sys_framework", "Framework: ESP-IDF");
          #endif
          boot_progress->execute(2);
          boot_log->execute("Boot", "Waiting for Wi-Fi...");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected());
          timeout: 10s
      - if:
          condition:
            - lambda: return (wifi_component->is_connected());
          then:  # Wi-Fi connected
            - lambda: |-
                boot_log->execute("Boot", "Wi-Fi connected");
                boot_progress->execute(3);
                if (current_page->state == "boot") {
                  #if ESPHOME_VERSION_CODE < VERSION_CODE(2024, 3, 0)  // Code for ESPHome earlier than v2024.3.0
                  disp1->set_component_text_printf("sys_ip", "IP: %s", network::get_ip_address().str().c_str());
                  #else  // Code for ESPHome v2024.3.0 or newer
                  disp1->set_component_text_printf("sys_ip", "IP: %s", network::get_ip_addresses()[0].str().c_str());
                  #endif  // ESPHome version based code
                  set_brightness->execute(100);
                }
                boot_log->execute("Boot", "Waiting for API...");
            - wait_until:
                condition:
                  - lambda: return (api_server->is_connected());
                timeout: 10s
            - if:
                condition:
                  - lambda: return (api_server->is_connected());
                then:  # API connected
                  - lambda: |-
                      boot_log->execute("Boot", "API connected");
                      boot_progress->execute(4);
                      if (!is_boot_complete()) boot_event->execute(true);
      - lambda: |-
          boot_log->execute("Boot", "Waiting for Blueprint...");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected() and api_server->is_connected() and is_boot_complete());
          timeout: 5s
      - lambda: |-
          boot_progress->execute(5);
          boot_log->execute("Boot", "Sending display settings");
          disp1->send_command_printf("brightness=%i", int(display_brightness->state));
          disp1->set_component_value("settings.brightslider", int(display_brightness->state));
          disp1->send_command_printf("brightness_dim=%i", int(display_dim_brightness->state));
          disp1->set_component_value("settings.dimslider", int(display_dim_brightness->state));
          disp1->send_command_printf("brightness_sleep=%i", int(display_sleep_brightness->state));
          disp1->send_command_printf("wakeup_page_id=%" PRIu8, get_page_id(wakeup_page_name->state.c_str()));
          boot_progress->execute(6);
          App.feed_wdt();
          yield();
          boot_log->execute("Boot", "Publish Nextion state");
          nextion_init->publish_state(disp1->is_setup());
          if (api_server->is_connected() and disp1->is_setup()) {
            esphome::api::CustomAPIDevice ha_event;
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
              {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "boot"},
                {"step", "nextion_init"}
              });
          }
          boot_progress->execute(7);
          App.feed_wdt();
          yield();
          boot_progress->execute(8);
          App.feed_wdt();
          yield();
          boot_log->execute("Boot", "Wait to finish");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected() and api_server->is_connected() and is_boot_complete());
          timeout: 5s
      - lambda: boot_progress->execute(9);
      - delay: 1s
      - lambda: boot_progress->execute(10);
      - delay: 1s
      - lambda: |-
          set_brightness->execute(display_brightness->state);
          boot_log->execute("Boot", "Jump to wake-up page");
          ESP_LOGD("script.page_boot", "Jump to wake-up page: %s", wakeup_page_name->state.c_str());
          App.feed_wdt();
          yield();
          goto_page->execute(wakeup_page_name->state.c_str());

  - id: !extend page_changed
    then:
      - lambda: |-
          if (current_page->state.empty() or current_page->state == "boot") page_boot->execute();

  - id: !extend stop_all
    then:
      - script.stop: boot_log
      - script.stop: boot_event
      - script.stop: boot_progress
      - script.stop: page_boot
      - script.stop: update_tft_info

  - id: update_tft_info
    mode: restart
    then:
      - while:
          condition:
            - lambda: return version_tft->state.empty();
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT version");
                version_tft->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !(version_tft->state.empty());
                timeout: 10s
      - while:
          condition:
            - lambda: return isnan(display_mode->state);
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT mode");
                display_mode->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !isnan(display_mode->state);
                timeout: 10s
      - while:
          condition:
            - lambda: return isnan(display_charset->state);
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT charset");
                display_charset->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !isnan(display_charset->state);
                timeout: 10s
...
