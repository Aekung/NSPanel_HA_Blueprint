#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - BOOT                                                                       #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
api:
  id: !extend api_server
  on_client_connected:
    then:
      - lambda: |-
          if (current_page->state == "boot") boot_log->execute("API", "Client connected");

  actions:
    # Configures NSPanel hardware (buttons, relays, etc.) settings
    - action: init_hardware
      variables:
        relay1_local_control: bool              # Enable/disable local control for Relay 1.
        relay1_icon: string                     # Icon for Relay 1 (e.g., "\uE3A5" for mdi:numeric-1-box-outline).
        relay1_icon_color: int[]                # RGB color array for Relay 1's icon.
        relay1_fallback: bool                   # Fallback state for Relay 1 in case of communication loss.
        relay2_local_control: bool              # Enable/disable local control for Relay 2.
        relay2_icon: string                     # Icon for Relay 2 (e.g., "\uE3A8" for mdi:numeric-2-box-outline).
        relay2_icon_color: int[]                # RGB color array for Relay 2's icon.
        relay2_fallback: bool                   # Fallback state for Relay 2 in case of communication loss.
        button_left: bool                       # Enable/disable left button status visualization.
        button_right: bool                      # Enable/disable right button status visualization.
        button_bar_pages: int                   # As uint representing the list of pages where the buttons bars will be visible
      then:
        - script.execute:
            id: boot_log
            category: Action
            log_message: init_hardware
        - if:
            condition:
              - lambda: return (!id(is_uploading_tft));
            then:
              - lambda: |-
                  // Relay settings
                  update_bitwise_setting(id(relay_settings), relay1_local_control, RelaySettings::Relay1_Local);
                  update_bitwise_setting(id(relay_settings), relay1_fallback, RelaySettings::Relay1_Fallback);
                  update_bitwise_setting(id(relay_settings), relay2_local_control, RelaySettings::Relay2_Local);
                  update_bitwise_setting(id(relay_settings), relay2_fallback, RelaySettings::Relay2_Fallback);

                  // Relay icons
                  if (not relay1_icon.empty()) copyStringToCharArray(id(home_relay1_icon), relay1_icon);
                  if (not relay2_icon.empty()) copyStringToCharArray(id(home_relay2_icon), relay2_icon);

                  // Relay icon's colors
                  // using namespace esphome::display;
                  if (relay1_icon_color.size() == 3) {
                    id(home_relay1_icon_color) = rgbTo565(relay1_icon_color);
                    disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
                  }
                  if (relay2_icon_color.size() == 3) {
                    id(home_relay2_icon_color) = rgbTo565(relay2_icon_color);
                    disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));
                  }

                  App.feed_wdt();
                  yield();

                  // Buttons bars settings
                  id(buttons_bars_pages) = button_bar_pages;
                  update_bitwise_setting(id(buttons_settings), button_left, ButtonSettings::ButtonLeft_Enabled);
                  update_bitwise_setting(id(buttons_settings), button_right, ButtonSettings::ButtonRight_Enabled);

                  // Refresh relays display
                  refresh_relays->execute(3);
                  refresh_hardware_buttons_bars->execute(3);

                  // Update blueprint status sensor
                  blueprint_status->publish_state(int(blueprint_status->raw_state) | (1 << 4));

display:
  - id: !extend disp1
    on_setup:
      - script.execute:
          id: boot_log
          category: Nextion
          log_message: on_setup
      - if:
          condition:
            - lambda: return (!id(is_uploading_tft));
          then:
            - delay: 1s
            - lambda: nextion_init->publish_state(true);
    on_touch:
      then:
        - lambda: |-
            if (page_id == 0) {  // Boot
              switch (component_id) {
                case 24:  // Reboot button
                  if (!touch_event) {  // Release
                    arch_restart();
                  }
                  break;
              }
            }

esphome:
  on_boot:
    - priority: 600.0  # This is where most sensors are set up.
      then:
        - lambda: |-
            boot_log->execute("on_boot", "Set time zone");
            set_timezone->execute(id(mui_timezone).c_str());
            boot_log->execute("on_boot", "Publish Blueprint progress (0)");
            if (isnan(blueprint_status->raw_state)) blueprint_status->publish_state(0);
            boot_log->execute("on_boot", "Publish device name");
            device_name->publish_state("${name}");
            boot_log->execute("on_boot", "Reset notification entities");
            notification_label->publish_state("");
            notification_text->publish_state("");
            notification_unread->turn_off();
        - wait_until:
            condition:
              - lambda: return (not isnan(stoi(baud_rate->state)));
            timeout: 60s
        - lambda: |-
            boot_log->execute("on_boot", "Set baud rate");
            if (stoi(baud_rate->state) != tf_uart->get_baud_rate()) set_baud_rate->execute(stoi(baud_rate->state), true);
        - wait_until:
            condition:
              - lambda: return disp1->is_setup();
            timeout: 60s
        - if:
            condition:
              - lambda: return (not disp1->is_detected());
            then:
              - lambda: boot_log->execute("on_boot", "Restart Nextion");
              - switch.turn_off: screen_power
              - delay: 2s
              - switch.turn_on: screen_power

script:
  - id: boot_log
    mode: queued
    # max_runs: 15
    parameters:
      category: string
      log_message: string
    then:
      - lambda: |-
          ESP_LOGI("script.boot_log", "%s: %s", category.c_str(), log_message.c_str());
          if (current_page->state == "boot") {
            disp1->send_command_printf("log_body.txt+=\"%s: %s\\r\"", category.c_str(), log_message.c_str());
          }

  - id: boot_event
    mode: restart
    parameters:
      init: bool
    then:
      - lambda: |-
          if (init) {
            esphome::api::CustomAPIDevice ha_event;
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
              {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "boot"},
                {"step", "start"}
              });
          }
      - while:
          condition:
            - lambda: return (blueprint_status->state < 99);
          then:
            - delay: 20s
            - lambda: |-
                if (blueprint_status->state < 99) {
                  esphome::api::CustomAPIDevice ha_event;
                  ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                    {
                      {"device_name", device_name->state.c_str()},
                      {"esphome_version", "${version}"},
                      {"type", "boot"},
                      {"step", "timeout"}
                    });
                }

  - id: boot_progress
    mode: restart
    parameters:
      step: uint
    then:
      - lambda: |-
          timer_reset_all->execute();
          if (step == 10) {
            ESP_LOGI("script.boot_progress", "Progress: Completed");
            disp1->set_component_value("boot.progress", 100);
          } else {
            step = std::min(100, int(round((blueprint_status->state + (step*10))/2)));
            ESP_LOGI("script.boot_progress", "Progress: %i%%", step);
            disp1->set_component_value("boot.progress", step);
          }
          if (current_page->state == "boot" and !isnan(display_charset->state) and !isnan(display_mode->state) and !version_tft->state.empty())
            disp1->send_command("tm_esphome.en=0");

  - id: page_boot
    mode: single
    then:
      - logger.log: Page boot called
      - lambda: |-
          boot_log->execute("Boot", "Starting sequence");
          boot_progress->execute(0);
          set_brightness->execute(100);
          update_tft_info->execute();
          boot_log->execute("Boot", "ESPHome FW v${version}");
          disp1->set_component_text("ver_firmware", "Firmware: ${version}");  // ESPHome version
          boot_progress->execute(1);
          #ifdef ARDUINO
          boot_log->execute("Boot", "Framework is Arduino");
          disp1->set_component_text("sys_framework", "Framework: Arduino");
          #elif defined(USE_ESP_IDF)
          boot_log->execute("Boot", "Framework is ESP-IDF");
          disp1->set_component_text("sys_framework", "Framework: ESP-IDF");
          #endif
          boot_progress->execute(2);
          boot_log->execute("Boot", "Waiting for Wi-Fi...");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected());
          timeout: 10s
      - if:
          condition:
            - lambda: return (wifi_component->is_connected());
          then:  # Wi-Fi connected
            - lambda: |-
                boot_log->execute("Boot", "Wi-Fi connected");
                boot_progress->execute(3);
                if (current_page->state == "boot") {
                  #if ESPHOME_VERSION_CODE < VERSION_CODE(2024, 3, 0)  // Code for ESPHome earlier than v2024.3.0
                  disp1->set_component_text_printf("sys_ip", "IP: %s", network::get_ip_address().str().c_str());
                  #else  // Code for ESPHome v2024.3.0 or newer
                  disp1->set_component_text_printf("sys_ip", "IP: %s", network::get_ip_addresses()[0].str().c_str());
                  #endif  // ESPHome version based code
                  set_brightness->execute(100);
                }
                boot_log->execute("Boot", "Waiting for API...");
            - wait_until:
                condition:
                  - lambda: return (api_server->is_connected());
                timeout: 10s
            - if:
                condition:
                  - lambda: return (api_server->is_connected());
                then:  # API connected
                  - lambda: |-
                      boot_log->execute("Boot", "API connected");
                      boot_progress->execute(4);
                      if (blueprint_status->state <= 99) boot_event->execute(true);
      - lambda: |-
          boot_log->execute("Boot", "Waiting for Blueprint...");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected() and api_server->is_connected() and blueprint_status->state > 99);
          timeout: 5s
      - lambda: |-
          boot_progress->execute(5);
          boot_log->execute("Boot", "Sending display settings");
          disp1->send_command_printf("brightness=%i", int(display_brightness->state));
          disp1->set_component_value("settings.brightslider", int(display_brightness->state));
          disp1->send_command_printf("brightness_dim=%i", int(display_dim_brightness->state));
          disp1->set_component_value("settings.dimslider", int(display_dim_brightness->state));
          disp1->send_command_printf("brightness_sleep=%i", int(display_sleep_brightness->state));
          disp1->send_command_printf("wakeup_page_id=%" PRIu8, get_page_id(wakeup_page_name->state.c_str()));
          boot_progress->execute(6);
          App.feed_wdt();
          yield();
          boot_log->execute("Boot", "Publish Nextion state");
          nextion_init->publish_state(disp1->is_setup());
          if (api_server->is_connected() and disp1->is_setup()) {
            esphome::api::CustomAPIDevice ha_event;
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
              {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "boot"},
                {"step", "nextion_init"}
              });
          }
          boot_progress->execute(7);
          App.feed_wdt();
          yield();
          boot_log->execute("Boot", "Set Home page elements");
          // Chips icon size
          for (int i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.chip%02d.font=%i", i, id(home_chip_font_id));
          }
          // Custom buttons icon size
          for (int i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.button%02d.font=%i", i, id(home_custom_buttons_font_id));
          }
          disp1->set_component_font("home.bt_notific", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_qrcode", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_entities", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.wifi_icon", id(home_chip_font_id));
          disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
          disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));
          #if defined(USE_ESP32_BLE_SERVER) || defined(USE_ESP32_BLE_CLIENT) || defined(USE_BLUETOOTH_PROXY) || defined(USE_IMPROV)
          disp1->set_component_text("home.bt_icon", "\uE0AE");
          #endif
          boot_progress->execute(8);
          App.feed_wdt();
          yield();
          boot_log->execute("Boot", "Wait to finish");
      - wait_until:
          condition:
            - lambda: return (wifi_component->is_connected() and api_server->is_connected() and blueprint_status->state > 99);
          timeout: 5s
      - lambda: boot_progress->execute(9);
      - delay: 1s
      - lambda: boot_progress->execute(10);
      - delay: 1s
      - lambda: |-
          set_brightness->execute(display_brightness->state);
          boot_log->execute("Boot", "Jump to wake-up page");
          ESP_LOGD("script.page_boot", "Jump to wake-up page: %s", wakeup_page_name->state.c_str());
          App.feed_wdt();
          yield();
          goto_page->execute(wakeup_page_name->state.c_str());

  - id: !extend page_changed
    then:
      - lambda: |-
          if (current_page->state.empty() or current_page->state == "boot") page_boot->execute();

  - id: !extend stop_all
    then:
      - script.stop: boot_log
      - script.stop: boot_event
      - script.stop: boot_progress
      - script.stop: page_boot
      - script.stop: update_tft_info

  - id: update_tft_info
    mode: restart
    then:
      - while:
          condition:
            - lambda: return version_tft->state.empty();
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT version");
                version_tft->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !(version_tft->state.empty());
                timeout: 10s
      - while:
          condition:
            - lambda: return isnan(display_mode->state);
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT mode");
                display_mode->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !isnan(display_mode->state);
                timeout: 10s
      - while:
          condition:
            - lambda: return isnan(display_charset->state);
          then:
            - lambda: |-
                ESP_LOGD("script.update_tft_info", "Updating TFT charset");
                display_charset->update();
                App.feed_wdt();
                yield();
            - wait_until:
                condition:
                  - lambda: return !isnan(display_charset->state);
                timeout: 10s

sensor:
  ##### Blueprint status #####
  # Bit # Settings step        #
  #  0  # reserved             #
  #  1  # page_home            #
  #  2  # qrcode               #
  #  3  # page_settings        #
  #  4  # relay_settings       #
  #  5  # global_settings      #
  #  6  # reserved             #
  #  7  # reserved             #
  ##############################
  - id: blueprint_status
    name: Blueprint
    platform: template
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: mdi:link-variant
    internal: false
    disabled_by_default: false
    filters:
      - lambda: |-
          if (!isnan(x) and x>0)
            return (x / 62) * 100.0f;
          else
            return 0;
    on_value:
      then:
        - script.execute: refresh_wifi_icon
...
